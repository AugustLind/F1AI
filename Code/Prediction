import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
import fastf1
from fastf1 import plotting

# Function to fetch race results for a specific year
def fetch_race_results(year):
    # Load the session data for the specified year
    session = fastf1.core.SessionResults(year)

    race_results = session.get_results()

    return race_results

# Fetch race results for the 2023 season
year = 2023
race_results = fetch_race_results(year)

# Rest of the code remains the same...



# Extract driver names and positions
driver_positions = {}

for result in race_results:
    for idx, row in result.iterrows():
        driver_name = f"{row['Forename']} {row['Surname']}"
        position = row['Position']
        
        if driver_name not in driver_positions:
            driver_positions[driver_name] = []
        driver_positions[driver_name].append(position)

# Convert positions to integers
def convert_positions(positions):
    return [int(pos) if pos != 'N/A' else 0 for pos in positions]

# Prepare data for LSTM
drivers = list(driver_positions.keys())
driver_results = [convert_positions(driver_positions[driver]) for driver in drivers]

X = []
y = []

for driver_index in range(len(drivers)):
    positions = driver_results[driver_index]

    if len(positions) >= 15:
        for i in range(len(positions) - 15):
            X.append(positions[i:i + 15])
            y.append(positions[i + 15])

X = np.array(X)
y = np.array(y)

# Split data into training and testing sets
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Build and train the LSTM model
model = Sequential([
    LSTM(64, activation='relu', input_shape=(15, 1)),
    Dense(1)
])

model.compile(optimizer='adam', loss='mse')
model.fit(X_train.reshape((-1, 15, 1)), y_train, epochs=50, batch_size=32, validation_data=(X_test.reshape((-1, 15, 1)), y_test))

# Predict the next position for each driver
next_positions = []

for driver in drivers:
    if len(driver_results[drivers.index(driver)]) >= 15:
        last_15_positions = np.array(driver_results[drivers.index(driver)][-15:])
        last_15_positions = last_15_positions.reshape((1, 15, 1))
        next_position = model.predict(last_15_positions)
        clipped_position = min(int(next_position[0][0]) + 1, 20)
        next_positions.append(clipped_position)
    else:
        print(f"Not enough data available to predict position for {driver}")

# Print the predicted positions for each driver
for i in range(len(drivers)):
    print(f"Predicted position for {drivers[i]}: {next_positions[i]}")
